{"ast":null,"code":"import fs from \"fs\";\nimport matter from \"gray-matter\";\nimport path from \"path\";\nimport _yaml from \"js-yaml\";\nvar postsDirectory = path.join(process.cwd(), \"src/pages/posts\");\nvar postCache;\n\nfunction fetchPostContent() {\n  if (postCache) {\n    return postCache;\n  } // Get file names under /posts\n\n\n  var fileNames = fs.readdirSync(postsDirectory);\n  var allPostsData = fileNames.filter(function (it) {\n    return it.endsWith(\".mdx\");\n  }).map(function (fileName) {\n    // Read markdown file as string\n    var fullPath = path.join(postsDirectory, fileName);\n    var fileContents = fs.readFileSync(fullPath, \"utf8\"); // Use gray-matter to parse the post metadata section\n\n    var matterResult = matter(fileContents, {\n      engines: {\n        yaml: function yaml(s) {\n          return _yaml.safeLoad(s, {\n            schema: _yaml.JSON_SCHEMA\n          });\n        }\n      }\n    });\n    var matterData = matterResult.data;\n    var slug = fileName.replace(/\\.mdx$/, \"\"); // Validate slug string\n\n    if (matterData.slug !== slug) {\n      throw new Error(\"slug field not match with the path of its content source\");\n    }\n\n    return matterData;\n  }); // Sort posts by date\n\n  postCache = allPostsData.sort(function (a, b) {\n    if (a.date < b.date) {\n      return 1;\n    } else {\n      return -1;\n    }\n  });\n  return postCache;\n}\n\nexport function countPosts(tag) {\n  return fetchPostContent().filter(function (it) {\n    return !tag || it.tags && it.tags.includes(tag);\n  }).length;\n}\nexport function listPostContent(page, limit, tag) {\n  return fetchPostContent().filter(function (it) {\n    return !tag || it.tags && it.tags.includes(tag);\n  }).slice((page - 1) * limit, page * limit);\n}","map":{"version":3,"sources":["/Users/christian/thoughts/src/lib/posts.ts"],"names":["fs","matter","path","yaml","postsDirectory","join","process","cwd","postCache","fetchPostContent","fileNames","readdirSync","allPostsData","filter","it","endsWith","map","fileName","fullPath","fileContents","readFileSync","matterResult","engines","s","safeLoad","schema","JSON_SCHEMA","matterData","data","slug","replace","Error","sort","a","b","date","countPosts","tag","tags","includes","length","listPostContent","page","limit","slice"],"mappings":"AAAA,OAAOA,EAAP,MAAe,IAAf;AACA,OAAOC,MAAP,MAAmB,aAAnB;AACA,OAAOC,IAAP,MAAiB,MAAjB;AACA,OAAOC,KAAP,MAAiB,SAAjB;AAEA,IAAMC,cAAc,GAAGF,IAAI,CAACG,IAAL,CAAUC,OAAO,CAACC,GAAR,EAAV,EAAyB,iBAAzB,CAAvB;AAWA,IAAIC,SAAJ;;AAEA,SAASC,gBAAT,GAA2C;AACzC,MAAID,SAAJ,EAAe;AACb,WAAOA,SAAP;AACD,GAHwC,CAIzC;;;AACA,MAAME,SAAS,GAAGV,EAAE,CAACW,WAAH,CAAeP,cAAf,CAAlB;AACA,MAAMQ,YAAY,GAAGF,SAAS,CAC3BG,MADkB,CACX,UAACC,EAAD;AAAA,WAAQA,EAAE,CAACC,QAAH,CAAY,MAAZ,CAAR;AAAA,GADW,EAElBC,GAFkB,CAEd,UAACC,QAAD,EAAc;AACjB;AACA,QAAMC,QAAQ,GAAGhB,IAAI,CAACG,IAAL,CAAUD,cAAV,EAA0Ba,QAA1B,CAAjB;AACA,QAAME,YAAY,GAAGnB,EAAE,CAACoB,YAAH,CAAgBF,QAAhB,EAA0B,MAA1B,CAArB,CAHiB,CAKjB;;AACA,QAAMG,YAAY,GAAGpB,MAAM,CAACkB,YAAD,EAAe;AACxCG,MAAAA,OAAO,EAAE;AACPnB,QAAAA,IAAI,EAAE,cAACoB,CAAD;AAAA,iBAAOpB,KAAI,CAACqB,QAAL,CAAcD,CAAd,EAAiB;AAAEE,YAAAA,MAAM,EAAEtB,KAAI,CAACuB;AAAf,WAAjB,CAAP;AAAA;AADC;AAD+B,KAAf,CAA3B;AAKA,QAAMC,UAAU,GAAGN,YAAY,CAACO,IAAhC;AAQA,QAAMC,IAAI,GAAGZ,QAAQ,CAACa,OAAT,CAAiB,QAAjB,EAA2B,EAA3B,CAAb,CAnBiB,CAqBjB;;AACA,QAAIH,UAAU,CAACE,IAAX,KAAoBA,IAAxB,EAA8B;AAC5B,YAAM,IAAIE,KAAJ,CACJ,0DADI,CAAN;AAGD;;AAED,WAAOJ,UAAP;AACD,GA/BkB,CAArB,CANyC,CAsCzC;;AACAnB,EAAAA,SAAS,GAAGI,YAAY,CAACoB,IAAb,CAAkB,UAACC,CAAD,EAAIC,CAAJ,EAAU;AACtC,QAAID,CAAC,CAACE,IAAF,GAASD,CAAC,CAACC,IAAf,EAAqB;AACnB,aAAO,CAAP;AACD,KAFD,MAEO;AACL,aAAO,CAAC,CAAR;AACD;AACF,GANW,CAAZ;AAOA,SAAO3B,SAAP;AACD;;AAED,OAAO,SAAS4B,UAAT,CAAoBC,GAApB,EAA0C;AAC/C,SAAO5B,gBAAgB,GAAGI,MAAnB,CACL,UAACC,EAAD;AAAA,WAAQ,CAACuB,GAAD,IAASvB,EAAE,CAACwB,IAAH,IAAWxB,EAAE,CAACwB,IAAH,CAAQC,QAAR,CAAiBF,GAAjB,CAA5B;AAAA,GADK,EAELG,MAFF;AAGD;AAED,OAAO,SAASC,eAAT,CACLC,IADK,EAELC,KAFK,EAGLN,GAHK,EAIU;AACf,SAAO5B,gBAAgB,GACpBI,MADI,CACG,UAACC,EAAD;AAAA,WAAQ,CAACuB,GAAD,IAASvB,EAAE,CAACwB,IAAH,IAAWxB,EAAE,CAACwB,IAAH,CAAQC,QAAR,CAAiBF,GAAjB,CAA5B;AAAA,GADH,EAEJO,KAFI,CAEE,CAACF,IAAI,GAAG,CAAR,IAAaC,KAFf,EAEsBD,IAAI,GAAGC,KAF7B,CAAP;AAGD","sourcesContent":["import fs from \"fs\";\nimport matter from \"gray-matter\";\nimport path from \"path\";\nimport yaml from \"js-yaml\";\n\nconst postsDirectory = path.join(process.cwd(), \"src/pages/posts\");\n\nexport type PostContent = {\n  readonly date: string;\n  readonly author: string;\n  readonly summary: string;\n  readonly title: string;\n  readonly slug: string;\n  readonly tags?: string[];\n};\n\nlet postCache: PostContent[];\n\nfunction fetchPostContent(): PostContent[] {\n  if (postCache) {\n    return postCache;\n  }\n  // Get file names under /posts\n  const fileNames = fs.readdirSync(postsDirectory);\n  const allPostsData = fileNames\n    .filter((it) => it.endsWith(\".mdx\"))\n    .map((fileName) => {\n      // Read markdown file as string\n      const fullPath = path.join(postsDirectory, fileName);\n      const fileContents = fs.readFileSync(fullPath, \"utf8\");\n\n      // Use gray-matter to parse the post metadata section\n      const matterResult = matter(fileContents, {\n        engines: {\n          yaml: (s) => yaml.safeLoad(s, { schema: yaml.JSON_SCHEMA }) as object,\n        },\n      });\n      const matterData = matterResult.data as {\n        date: string;\n        title: string;\n        author: string;\n        summary: string;\n        tags: string[];\n        slug: string;\n      };\n      const slug = fileName.replace(/\\.mdx$/, \"\");\n\n      // Validate slug string\n      if (matterData.slug !== slug) {\n        throw new Error(\n          \"slug field not match with the path of its content source\"\n        );\n      }\n\n      return matterData;\n    });\n  // Sort posts by date\n  postCache = allPostsData.sort((a, b) => {\n    if (a.date < b.date) {\n      return 1;\n    } else {\n      return -1;\n    }\n  });\n  return postCache;\n}\n\nexport function countPosts(tag?: string): number {\n  return fetchPostContent().filter(\n    (it) => !tag || (it.tags && it.tags.includes(tag))\n  ).length;\n}\n\nexport function listPostContent(\n  page: number,\n  limit: number,\n  tag?: string\n): PostContent[] {\n  return fetchPostContent()\n    .filter((it) => !tag || (it.tags && it.tags.includes(tag)))\n    .slice((page - 1) * limit, page * limit);\n}\n"]},"metadata":{},"sourceType":"module"}